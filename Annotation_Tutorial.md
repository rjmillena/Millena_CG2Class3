## About

This tutorial is intended to detail an approach to assessing and
analyzing long reads generated by ONT Nanopore sequencers. The goal is
to walk through processing and annotating ONT genomic reads.
Research-wise, we focus on assembly of long reads with the ultimate goal
of annotating a whole genome of a non-model organism (ideally of a
twisted-wing parasite belonging to the order Strepsiptera).

## Assembly and Annotation of Long Reads

This should all take place on the AMNH clusters (log in to Huxley) and
assumes that conda has been installed and activated with
`source ~/.bashrc`. Remember to replace any aliases (`$ASSEMBLY`) with
your own paths or files.

### 1) Assembly with [Flye](https://github.com/fenderglass/Flye/blob/flye/docs/USAGE.md)

We will use Flye to assemble our Nanopore-generated long reads. Flye is
a de novo assembler that works great with single-molecule sequencing
reads like those from the ONT MinION that we will be working with. First
create a conda environment and install the assembler Flye and activate
it:

    conda create -n flye -c bioconda flye
    conda activate flye

Then run Flye! `$READS` is a fastq file. This step may take a while.

    flye --nano-hq $READS -g 150m -o $OUTPUT_DIR

-   –nano-hq is a relatively new (as of right now) mode for the latest
    version of the ONT basecaller and kits/flow cells
-   -g indicates the estimated genome size, which we have set at 150 mb

This will output a fasta file containing the polished contigs in your
output directory. You can also include the flag `--scaffold` anywhere in
the line, which would use the longest reads to scaffold the rest. This
does take some computational time, though, and may not be worth the
increased contiguity.

### 2) Quality Assessment with [BUSCO](https://busco.ezlab.org/busco_userguide.html#mandatory-arguments)

After assembly, we will do quality assessment. We will run BUSCO to
check for assembly completeness—we want the score to be in the mid to
high 90s.

    conda create -n busco -c bioconda busco
    conda activate busco

Then run this line, which will download the database of core orthologs
present in Insecta.`$ASSEMBLY` is a fasta file.

    busco -i $ASSEMBLY -o busco -l insecta -m genome -c 24

-   -l indicates the lineage of the dataset being downloaded
-   -m sets assessment mode: genome, protein, or transcriptome
-   -c indicates the number of threads/cores to use

Once the database is downloaded, you need to submit this same line as a
job. Do this by creating a script (`nano busco.sh`) and pasting the same
line into it. It should look like this:

    #!/bin/bash
    busco -i $ASSEMBLY -o busco -l insecta -m genome -c 24

and then `qsub busco.sh`. Once the job is complete, you can view the
output .txt file in the directory you ran this from to see how many
busco genes are present.

### 3) Checking for Contaminants with Blobtools

First, we need to blast the genome against the NCBI nucleotide database.
First download the database if it’s not already present:

    gunzip -d ncbi-blast-2.10.1+-x64-linux.tar.gz
    tar xvpf ncbi-blast-2.10.1+-x64-linux.tar
    update_blastdb.pl

We also need minimap 2, samtools, and blobtools.

    conda create -n minimap2 -c bioconda minimap2

    conda create -n samtools -c bioconda samtools

    conda create -n blobtools -c bioconda blobtools

Then create a script like this to run BLAST, with `nano blast.sh`:

    #!/bin/bash

    module purge
    module load python/2.7
    module load blast
    blastn \
    -task megablast \
    -query $PATH_TO_ASSEMBLY/$ASSEMBLY \
    -db /zblastDatabase/nt \
    -outfmt '6 qseqid staxids bitscore std' \
    -max_target_seqs 1 \
    -max_hsps 1 \
    -num_threads 16 \
    -evalue 1e-25 \
    -out $ASSEMBLY.blast.out

-   -outfmt and the quoted line following orders the blast output in a
    way that lets blobtools read it

Then map all the reads against our assembled genome with
[minimap](https://lh3.github.io/minimap2/minimap2.html). `$RAWREADS` are
the raw reads you got from the nanopore.

    conda activate minimap2
    minimap2 -ax asm20 ../../$ASSEMBLY ../../$PATH_TO_RAW_READS/$RAWREADS > $MINIMAP.sam

-   -a generates the output alignments in SAM format
-   -x applies the option asm20, which is a preset for long assembly to
    reference mapping with up to 20% sequence divergence. Other options
    include asm5, asm10, map-ont, map-hifi, and splice.

Now sort and index the minimap output using
[samtools](http://www.htslib.org/doc/samtools-sort.html).

    conda activate samtools
    samtools view --threads 16 -o $MINIMAP.bam $MINIMAP.sam
    samtools sort -m 7G -o $SORTED.bam -T sorted_temp --threads 16 $MINIMAP.bam

-   view prints the SAM alignment into a BAM format
-   sort sorts alignment by the leftmost coordinates
    -   -m indicates approximately the maximum required memory per
        thread, here 7 gigabytes
    -   -T writes temporary files to sorted_temp.nnnn.bam

Finally, you can run
[blobtools](https://blobtools.readme.io/docs/create) with this command:

    conda activate blobtools
    blobtools create -i ../$ASSEMBLY -b $SORTED.bam -t \
    $ASSEMBLY.blast.out -o blobplot  --nodes \
    data/nodes.dmp --names data/names.dmp

-   create is a module that takes the assembly (`-i`), bam file (`-b`),
    hits file (`-t`) and creates a blobplot output with the prefix
    blobplot (`-o`). The `-nodes` and `-names` files come with
    installation.

You will get images detailing information on the genome coverage and its
BLAST hits—they will look something like
[this](https://www.researchgate.net/figure/BlobPlot-of-the-genome-assembly-before-removing-contamination-Each-circle-is-a-contig_fig1_344510652).

If the Blobplot output shows a high amount of “contamination”, it may be
that the most similar sequences are from very well-covered/studied
vertebrates. Since the assignments are based off of known protein and
nucleic acid sequence databases, the relatively higher amount of work
and records on vertebrates may be messing with these results—especially
since Strepsiptera barely has any sequences in these databases. This was
an issue when assessing a genome of Odonata, so it will likely pose a
challenge in most other insect orders as well.

We are using Blobplot for this purpose instead of something more general
like DotPlot with mummer or yak because Blobplot is a generally accepted
assessment and visualization tool for sequence quality in genomic
papers. It also provides a more detailed view of what taxa are contained
in the sequences than what can be given with BLASTing alone. This is
important especially for the study of an endoparasite such as
Strepsiptera, which is more likely to have host “contamination” present
in its sample.

### 3) (Alternative) Checking for Contaminants with NCBI Itself

You can ask NCBI directly to check for and remove contaminants, but this
takes a bit more time. This way involves uploading your genome assembly
to the NCBI genome submission tool
[here](https://submit.ncbi.nlm.nih.gov/about/genome/), and they will run
their own tests, then email you the contaminants that they identify.

You can then use [this
script](https://github.com/campanam/genome_decontaminate) to mask your
contaminants.

### 4) Masking Repetitive Elements with [RepeatMasker](https://www.animalgenome.org/bioinfo/resources/manuals/RepeatMasker.html)

The first step now in annotation is modeling and masking repetitive
elements, which we will do with RepeatModeler and RepeatMasker.
RepeatModeler contains both programs, so we only need to install
RepeatModeler with bioconda.

    conda create -n repeatmodeler -c bioconda repeatmodeler
    conda activate repeatmodeler

Create a database of the genome:

    BuildDatabase -name $DATABASE_NAME -engine ncbi $PATH_TO_GENOME_ASSEMBLY

Model repeats in the assembly:

    RepeatModeler -database  $DATABASE_NAME -engine ncbi  -pa $NUMBER_OF_THREADS 

Then mask the repeats in the assembly.

    RepeatMasker -pa $NUMBER_OF_THREADS -gff -nolow -lib $REPEATMODELER_OUTPUT $ASSEMBLY

-   -pa allows for multiple processor use
-   -gff specifies the output file as .gff
-   -nolow does not display simple repeats or low complexity DNA in the
    annotation
-   -lib allows the use of a custom library

This will give you a .gff file, which is a general feature format file
describing genomic features.

### 5) Annotation with [miniprot](https://github.com/lh3/miniprot/blob/master/README.md#usage)

The last step is annotation. Download and compile miniprot here:

    git clone https://github.com/lh3/miniprot
    cd miniprot && make

Then run cd-hit to cluster a set of Strepsiptera proteins, starting at
90% similarity:

    cd-hit -i $INPUT -o $OUTPUT -c 0.9 -n 2

-   -i indicates the input file, which should be a fasta file containing
    all the strepsipteran protein sequences
-   -o indicates the output file, which will be a protein .fasta
-   -c indicates the similarity percentage, or the clustering threshold
-   2 is the number of proteins that miniprot will compare at the same
    time

Then run BUSCO on the clustered protein set.

    conda activate busco
    busco -i $OUTPUT -l insecta -o $BUSCO_PROT_OUTPUT.txt -m prot -c 24

Keep repeating these steps, dropping the `-c` similarity value in
`cd-hit`, until the BUSCO score of the reads shows a duplicate level
below 5%. Then map these reads to both the masked and unmasked
assemblies with minimap, and compare the resulting annotation sets using
BUSCO.

Performing annotation in this way can take less than an hour, and has
been successful in annotation in odonate genomes like that of
*Tanypteryx hageni*. Alternative annotation methods that have been more
widely used such as
[MAKER](https://gist.github.com/darencard/bb1001ac1532dd4225b030cf0cd61ce2),
[GeMoMa](http://www.jstacs.de/index.php/GeMoMa), or
[Augustus](https://github.com/Gaius-Augustus/Augustus) take much longer
due to increased computational load—days to months longer—but can be
considered more robust. Using methods in combination (such as using
miniprot to train the models of Augustus) can be a good option too.

Maker works best when provided a transcriptome plus all protein
annotations available for the group, which may not be an option for
Strepsiptera (the one published genome has not been fully annotated).
GeMoMa works well if provoded the annotated genome of a closely related
species, which is inapplicable in Strepsiptera for the same reason as
already stated. Augustus predicts genes in genomic sequences, but has
been trained with gene sets from model organisms and may need to be
re-trained with gene sets from non-model organisms (which may or may not
be available).

This genome can be assembled to chromosome length if combined with
PacBio Hi-C data—apparently we would just send this resultant draft
strepsipteran genome to [DNA ZOO](https://www.dnazoo.org/usage) and they
would be willing to align and assemble it! This has already been done
for our lab with the aforementioned *Tanypteryx hageni* genome, and
their pipeline summary can be found
[here](https://www.dnazoo.org/assemblies/Tanypteryx_hageni). This
pipeline that I have developed is very similar to that used for the
*Tanypteryx* genome, but is simpler and has some differences in software
etc. Due to time constraints and not having the data or easy access to
genome-length raw reads from the Nanopore I have not tested many of the
steps, but I will hopefully in the near future.

# Citations (in order of use)

-   Grüning B., Ryan D., Andreas S., Brad A.C., Jillian R., Christopher
    H.T., Renan V., the Bioconda Team, Johannes K. (2018) Bioconda:
    Sustainable and Comprehensive Software Distribution for the Life
    Sciences. *Nature Methods*, <doi:10.1038/s41592-018-0046-7>.
-   Mikhail K., Jeffrey Y., Yu L., Pavel P. (2019) “Assembly of Long
    Error-Prone Reads Using Repeat Graphs”, *Nature Biotechnology*,
    <doi:10.1038/s41587-019-0072-8>
-   Manni, M., Berkeley, M. R., Seppey, M., & Zdobnov, E. M. (2021).
    BUSCO: Assessing genomic data quality and beyond. *Current
    Protocols, 1*, e323. doi: 10.1002/cpz1.323
-   Camacho C., Coulouris G., Avagyan V., Ma N., Papadopoulos J., Bealer
    K., & Madden T.L. (2008) BLAST+: architecture and applications. *BMC
    Bioinformatics 10*:421. PubMed
-   Laetsch, D. R., & Blaxter, M. L. (2017). BlobTools: Interrogation of
    genome assemblies. *F1000Research, 6*(1287), 1287.
    <doi:10.5281/zenodo.845347>
-   Li, H. (2018). Minimap2: pairwise alignment for nucleotide
    sequences. *Bioinformatics, 34*(18), 3094-3100.
-   Li, H., Handsaker, B., Wysoker, A., Fennell, T., Ruan, J., Homer,
    N., … & Durbin, R. (2009). The sequence alignment/map format and
    SAMtools. *Bioinformatics, 25*(16), 2078-2079.
-   Flynn, J. M., Hubley, R., Goubert, C., Rosen, J., Clark, A. G.,
    Feschotte, C., & Smit, A. F. (2020). RepeatModeler2 for automated
    genomic discovery of transposable element families. *Proceedings of
    the National Academy of Sciences, 117*(17), 9451-9457.
-   Li, H. (2022). Protein-to-genome alignment with miniprot. arXiv
    preprint arXiv:2210.08052.
-   Cantarel, B. L., Korf, I., Robb, S. M., Parra, G., Ross, E., Moore,
    B., … & Yandell, M. (2008). MAKER: an easy-to-use annotation
    pipeline designed for emerging model organism genomes. *Genome
    research, 18*(1), 188-196.
-   Keilwagen, J., Hartung, F., & Grau, J. (2019). GeMoMa:
    homology-based gene prediction utilizing intron position
    conservation and RNA-seq data. *Gene Prediction* (pp. 161-177).
    Humana, New York, NY.
-   Hoff, K. J., & Stanke, M. (2019). Predicting genes in single genomes
    with AUGUSTUS. *Current protocols in bioinformatics, 65*(1), e57.
